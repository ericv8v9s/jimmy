; INPUT
(assign x 7)
(assign y 2)
(assert (not (= y 0)))
[assert (not (= y 0))]

[=intr (= x x)]
(assign r x)
[assign (= x r)]
[mark xr1]

[add0 (= r (+ r 0))]
[mark xr2]
; substitute xr2 (which must be of form (= a b)) into xr1: r -> (+ r 0)
[[sub xr2 xr1] (= x (+ r 0))]
[mark xr3]

[mult0 (= 0 (* 0 y))]
[mark y0]
[[sub y0 xr3] (= x (+ r (* 0 y)))]
[mark xr4]

[=intr (= 0 0)]
(assign q 0)
[assign (= 0 q)]
[[sub (= 0 q) xr4] (= x (+ r (* q y)))]  [mark invar]  ; loop invariant


(while (<= y r)
	[assume (= x (+ r (* q y)))]  [mark invar]
	; To handle (assign r (- r y),
	; we need to first prove something with (- r y) in it.
	[show_proof_state begin-while]

	[[sub [add0 (= r (+ r 0))] invar] (= x (+ (+ r 0) (* q y)))]  [mark invar]
	[[sub [subt0 (= 0 (- y y))] invar]
			(= x (+ (+ r (- y y)) (* q y)))]  [mark invar]
	[[sub [-+ (= (- y y) (+ y (- y)))] invar]
		(= x (+ (+ r (+ y (- y))) (* q y)))]  [mark invar]
	[+assoc (= (+ (+ r (+ y (- y))) (* q y)) (+ r y (- y) (* q y)))]  [mark tmp]
	[[sub tmp invar] (= x (+ r y (- y) (* q y)))]  [mark invar]

	[+comm (= (+ r y (- y) (* q y)) (+ r (- y) y (* q y)))]  [mark tmp]
	[[sub tmp invar] (= x (+ r (- y) y (* q y)))]  [mark invar]

	[+assoc (= (+ r (- y) y (* q y)) (+ (+ r (- y)) y (* q y)))]  [mark tmp]
	[[sub tmp invar] (= x (+ (+ r (- y)) y (* q y)))]  [mark invar]

	[-+ (= (- r y) (+ r (- y)))]
	[=flip (= (+ r (- y)) (- r y))]  [mark tmp]
	[[sub tmp invar] (= x (+ (- r y) y (* q y)))]  [mark invar]

	(assign r (- r y))
	[assign (= x (+ r y (* q y)))]  [mark crit]
	; derive invar (= x (+ r (* (+ q 1) y))) from here

	[[sub [mult1 (= y (* y 1))] crit]
			(= x (+ r (* y 1) (* q y)))]  [mark crit]
	[[sub [*comm (= (* q y) (* y q))] crit]
			(= x (+ r (* y 1) (* y q)))]  [mark crit]

	[+assoc (= (+ r (* y 1) (* y q)) (+ r (+ (* y 1) (* y q))))]  [mark tmp]
	[[sub tmp crit] (= x (+ r (+ (* y 1) (* y q))))]  [mark crit]

	[*distr (= (* y (+ 1 q)) (+ (* y 1) (* y q)))]
	[=flip (= (+ (* y 1) (* y q)) (* y (+ 1 q)))]  [mark tmp]
	[[sub tmp crit] (= x (+ r (* y (+ 1 q))))]  [mark crit]

	[[sub [+comm (= (+ 1 q) (+ q 1))] crit]
			(= x (+ r (* y (+ q 1))))] [mark crit]

	(assign q (+ q 1))
	[assign (= x (+ r (* y q)))]  [mark invar]
	[[sub [*comm (= (* y q) (* q y))] invar]
			(= x (+ r (* q y)))]  ; we have loop invariant again
	[show_proof_state end-while])

[show_proof_state before-while]

[while (and
	(not (<= y r))  ; negation of loop condition
	; this must be known before the loop and shown to be maintained by the loop
	(= x (+ r (* q y))))]

[show_proof_state end]

; OUTPUT
(print q)
(print r)
